1. 为什么连接是三次握手，而断开确实四次挥手?

因为建立连接的时候，双方没有数据的来往，可以把ACK和SYN放到一个报文进行发送。

但在关闭连接时，收到FIN报文后，它表示对方没有数据需要再发送了，但自己可能还有数据要发给对方，这是发送一个ACK报文，表示自己收到了FIN报文。当自己也没有数据需要发送的时候，就发送一个FIN表示你现在同意关闭连接了，对面再发送一个ACK即完成断开。

2. 为什么CLIENT主机最后一次发送ACK后不立即断开，而是经过TIME_WAIT状态经过2MSL(最大报文生存时间)后才返回到CLOSE状态？

   因为网络时不可靠的，有可能最后一个ACK会丢失，SERVER端如果没有收到ACK，会再次发送FIN报文，所以CLIENT主机不能立即关闭，他需要确认SERVER端收到了ACK。CLIENT进入TIME_OUT状态后，会设置一个计时器，等待2MSL后进入CLOSE状态，如果在这个时间内再次收到FIN，就会重新发送ACK，并重新等待2MSL.

3. 为什么不能用两次握手进行连接？

   - 防止已经失效的连接请求报文又传到服务器，因而产生错误。当client发送一个请求连接后，在某个网络节点发生延迟，某个时间才到达server端，本来这是一个失效的报文。但B受到后，会发送一个SYN+ACK，如果这时采用的是两次握手，那么表示已经建立连接，但A端这时可能并没有要求建立连接，这样就会造成资源浪费。
   - 在不可靠的信道上可靠的传输信息。如果是两次握手就完成连接的话，当server端发送SYN+ACK之后。如果这条消息并未发送成功，那么CLIENT会继续发送SYN，这样server端会建立多个无效连接。
   - 确保双方对序列号达成一致，当server发送SYN+ACK+seq，表示自己从这个序列号开始发送，但无法确保这个消息被成功发送，必须收到ACK后，才能确定双方对序列号达成一致。best

4. 如果已经建立连接，但客户端出现故障会怎么办？

5. 如何优雅的断开套接字连接？

   close函数意味着完全断开连接。A主机发送完数据后，调用close关闭连接，之后再也无法接收主机B传输的数据。这时就可以使用半关闭，考虑这种情况，服务端将约定的文件发送给客户端后，客户端收到后发送“Thank you”字符串给服务端。
   
6. 什么时候会出现大量的TIME-WAIT状态？

   当请求量很大，并且大多是短连接请求的时候，就会在服务器出现大量的TIME-WAIT状态。
   
7. http的缺点有哪些？
	- 使用明文（不加密），内容可能会被窃听
	- 不验证通信方的身份，因此有可能遭遇伪装
	- 无法验证报文的完整性，可能被修改
	
8. 如何防止报文被窃听？

   1. 对通信加密，即通过SSL建立安全的通信线路，之后在这个线路上进行http通信。
   2. 对内容加密，即把http报文所包含的内容进行加密，但要求客户端和服务端都要具有**加密和解密**机制。当该方式内容有可能被修改。因为通信通道无法保证是安全的。

9. 不验证通信的身份会有哪些隐患?

   1. 无法确定自己发送的目标服务器是否是伪装服务器。同理，无法判断是否伪装客户端。
   2. 无法确定对方对于某些资源是否具有访问权限。
   3. 无意义的请求也会被接收，无法阻止DOS攻击

10. 边缘触发相对条件触发的优点？

    可以分离接收数据和处理数据的时间点。比如服务器从客户端A,B,C接收数据，可能会出现一下情况，即C，B正在发送数据，但A还未连接。可以通过边缘触发，服务器也能决定读取和处理这些数据的时间点。

11.条件触发无法做到区分数据接收和处理吗？

​		可以，但在输入缓冲收到数据时，每次调用epoll\_wait函数都会产生相应的事件，而且事件数会累加，服务器会又很大的负担。

12.sizeof和strlen的区别？

​	sizeof是一个运算符，求目标内存的字节数，和其内容无关。而且sizeof是在编译时计算，不能用来返回动态内存的大小。strlen是计算一个字符串的长度读取到\0位置，比如`char s[] = {'1','2','\0','3'}`获得的长度也是2.

13.strcpy和strncpy的缺陷分析.

	1. 内存越界，当dest的长度小于src的长度时，该函数不会判断目标数组的长度，所以会造成内存越界。
 	2. 当二者长度相等时，会丢失'\0';
 	3. 对于strncpy当src的长度小于Count,时，会不断地在后面补充\0;

14.malloc最大能分配的空间数?

​	Linux下一般为3G，windows下一般为2G,不过通常情况下无法申请到地址空间的上限，因为存在内存碎片，当剩余的空间不是连续内存的时候也会失败。

15.处理哈希冲突的方法？

 1. 开放定址法

    把哈希结果加上一个增量序列，再对哈希表长度取膜，直到不再冲突为止。

2. 再哈希法

   利用不同的哈希函数，即在发生冲突时计算另一个哈希函数的地址，直到不再发生冲突为止。

3. 链地址法

   将哈希结果相同的值记录在同一个线性链表中，

4. 建立公共溢出区

   建立一个溢出区，不管得到的哈希地址是什么，一旦发生冲突都放入这个溢出区。同理查找时也是在这里查找。

16. 如何判断new是否分配成功？什么情况下会分配失败？

    1. 检查返回的是否是个空值，即是否为0。
    2. 会抛出一个bad_alloc的异常（默认时抛出的）

    失败情况：在申请一个很大的内存时，但分配的堆里面没有这么大的内存。

17.C++ 多态，动态绑定的原理?

1. 编译器在父子按类中有虚函数时，会自动为每个类的虚函数生成一份虚函数表。该表是一个一维数组，虚表保存每个虚函数的入口地址。
2. 编译器会在每个类的里面保存一个虚表指针，即指向类所属的虚函数，根据对象的类型去初始化这个虚指针，让其指向正确的虚表。从而找到正确的函数

> 当子类对父类的虚函数没有重写时，子类的虚表指针保存的是父类的虚表，当子类对父类重写时，子类虚表指针保存的是子类的虚表。当子类有自己的虚函数时，在虚表中将此虚函数地址添加到后面。

	3. 程序运行时，会自动调用构造函数，在构造函数中创建虚表并对虚表进行初始化。构造子类对象时，会先调用父类的构造函数，再调用子类的构造函数。

18.结构体大小计算。

```cpp
class A{
public:
    short v;
    char ch;
    int x;
    long long c;
};
class B{
public:
    short v;
    int x;
    char ch;
    long long c;
};
class C {
public:
	int val1;
	long long val2;
	virtual void show() {

	}
};
//类C 这个和对其方式有关,如果选择4字节对齐,结果是16,8字节对齐结果是24
```

A 和B 只是排列的不同，但A的大小时16B,而B时24B.

因为为了CPU能够快速访问，提高访问效率，变量的起始地址应该具有某些特性，这就是所谓的“对齐”。比如4字节的int型变量，那它的起始地址就应该在4字节的边界上，即起始地址可以被4整除

对于A其成员变量起始地址为: v 0, ch 2,x 4,c ,8。因此总大小是16.

对于B其成员变量其实地址为: v 0, x 4,ch 8,c 16。因此总大小是24. 

19.C++程序编译的四个阶段。

​	对于hello.c这个文件

1. 预处理阶段。

   编译器把C程序的头文件插入进来，还有宏的替换。把hello.c预处理为hello.i

2. 编译阶段

   这个阶段主要做词法分析，语法分析，语义检查。检查无错误后，把代码翻译成汇编语言。把hello.i编译为hello.s

3. 汇编阶段

   把汇编语言翻译成机器语言保存到hello.o(二进制文本)

4. 链接阶段

   把.o文件链接成可执行文件。

   这里，如果我们使用了printf函数，再预编译阶段包含进去的stdio.h也只有该函数的声明，而没有该函数的实现，系统把这些实现都放到stdc++的库文件下面了，再没有特别指定是，g++会从/usr/lib里面查找。
   
   add:如果一个函数定义但未实现，如果我们使用这个函数，会在哪个阶段报错？
   
   ​	链接阶段。

20.已连接的UDP套接字和TCP有什么区别？

1. 给UDP套接字调用connect并不会像TCP一样发出三次握手，内核只是检查是否合法

21.一个类的析构函数何时会被调用？

	1. 对象声明周期结束时，被销毁时。
 	2. 主动调用delete.
 	3. 类B时类A的派生类，当B的析构函数被调用时，类A的析构函数也被调用。（未被声明为虚析构函数时）

22.虚析构函数的作用？

​	如果一个基类指针指向它的派生类，当delete它时，不适用虚析构函数的话，它只会调用基类的析构函数，这可能会导致内存无法被释放。声明为虚析够函数的话，再删除时会先调用派生类析构函数，再调用基类析构函数。

23.const 限定符的各个特点?

```cpp
const int v1 = 100;
v1 = 20;//报错，常量不能被修改.
const int v2;//报错，因为v2是一个未经初始化的常量。
```

**默认状态下，const对象被设定为仅在文件内有效**

> 注意，如果一个.h文件中存在一个const,而main函数的文件报过了这个.h那么它们是在一个编译单元,可以使用这个const,如果在一个.cpp文件中,没有包括的话,只有通过extern的方法可以使用

一个文件中定义的const,在其他文件也能使用的方法

```cpp
/*test.cpp*/
extern const int value = 100;//表明value并非本文件所有
/*main.cpp*/
extern const int value;//表示要从其他文件中寻找这个value
```

const的引用

```cpp
double val = 3.14;
const int &ri = val;//这里如果不加const的话,会报错 
/*这里实际为了确保ri绑定到一个整数,编译器会把上面的代码变为下面的情况*/
const int temp = val;
const int &ri = temp;
```

**const引用允许用任意表达式作为初始值**

const和指针

```cpp
const int val = 100;
int *ptr1 = &val;//报错,普通指针不能指向一个const常量
const int *ptr2 = &val;//正确,但不能给*ptr2赋值
int val2 = 100;
int *const ptr3 = &val2;//正确,但这个指针不能改变指向,即一直指向val
int *const ptr4;//错误,该指针必须初始化.
```

24.拷贝构造函数，以及会在哪些情况下调用它?

定义:如果一个构造函数的第一个参数是自身类型的引用，且任何额外的参数都有默认值，则此构造函数就是拷贝构造函数。

```cpp
class Base{
public:
	Base(){}
    Base(const Base &_b){}
}
```

拷贝构造函数会被隐式的调用，所以不应该是explicit(修饰的构造函数，不能被隐式调用)的

拷贝构造函数被调用的情况:

1. 用 = 定义变量时`Base b;Base a = b;`，即这种.
2. 将一个对象作为实参返回给一个非引用类型的参数时.`Base b(a)`

3. 从一个返回类型为非引用类型的函数返回一个对象.

25.拷贝构造函数为什么第一个参数必须是引用类型？

​	因为，当实现了拷贝构造函数后，就不会有默认的拷贝构造函数了，即只有自己实现的，如果其参数不是引用类型的，那么我们为了调用拷贝构造函数，必须要拷贝它的实参，但为了拷贝实参又需要调用拷贝构造函数，矛盾了。

注意拷贝构造函数只会在初始化时调用，赋值初始化也是调用拷贝构造函数，例如`Base b = a` 

26.explicit的作用是什么？

防止构造函数被隐式调用，即防止隐式转化的情况发生。

```cpp
class Base {
public:
	explicit Base(int _value) {
		value = _value;
	}
private:
	int value;
};
main(){
    Base b = 2;//这时会报错，如果构造函数不加explicit的话可以。
}
```

27.C++中，类成员是在析构函数中被销毁的吗？

​	注意，析构函数自身并不直接销毁成员，成员实在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分进行。

28.谈谈右值引用？

​	为了能够支持移动操作，新标准引入了——右值引用，即必须绑定到右值的引用，使用&&,而不是&.

右值引用的一个重要性质就是只能绑定到一个将要销毁的对象。

```cpp
int val = 42;
int &vl = val;//正确，左值引用。
int &&vr = val;//错误，因为变量表达式是左值
int &vl2 = val*100;//错误，因为结算结果是一个右值
int &&vr2 = val*100;//正确，右值引用。
int &&vr3 = vr2;//错误，对确实是错误，因为变量表达式是一个右值
```

29.C/C++ 程序内存的分配情况？

	1. 栈区：由编译器自动分配释放，存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等
 	2. 堆区：一般由开发人员分配释放，如果不释放可能会由操作系统释放。
 	3. 全局区（静态区）:存放全局变量、静态变量、常量，程序结束后由系统释放。
 	4. 文本常量区：存放常量字符串的地方，程序结束后由系统释放。
 	5. 程序代码区：存放函数体的二进制代码。

30.谈谈线程与进程和协程的区别?为什么线程效率更高？

1. 进程是资源分配的最小单位、线程是程序执行的最小单位，它是进程的一个流。
2. 协程是一种用户态的线程，他由程序员自己去管理，切换时不涉及操作系统。

3. 进程有自己的独立空间，每启动一个进程，系统都会为它分配所有的地址空间，即栈、堆、全局区、程序代码区等。而线程只会分配栈空间、其堆等其他内存空间是共享的。所以切换一个进程要比切换线程花费大很多。

4. 线程之间的通信更加方便，可以利用全局变量、静态变量、堆等。而进程要使用IPC的通信方式

5.  谈谈进程的几种基本状态

    1. 创建状态：进程创建需要申请一个PCB，向其中填写相关的信息，完成资源分配，如果无法满足，就无法被调度。
    2. 就绪状态：进程已经分配了所需要的资源，只需要分配CPU就可以运行（被调度）
    3. 执行状态：就绪状态被调度后，就被进入此状态。
    4. 阻塞状态：正在执行的进程由于某些事情（IO请求、申请缓存失败）等暂时无法运行，在满足请求后重新进入就绪状态。
    5. 终止状态：进程结束、出现错误，被系统终止等，无法再被执行。

    ![img](..\img\进程状态转化图.png)

6.  **请你设计一种LRU(最近最少使用)的缓存机制，要求get,set操作均为O(1)的时间复杂度。**

    ​	设计思想，哈希表+链表。链表节点信息，key(位置)-value(值)，哈希表节点信息,key(位置)-value(节点信息).链表head - > tail 从左往右最近使用最多。head是最近使用最少的。
    
    - get(int key)操作，判断哈希表中是否存在这个位置，不存在输出-1，存在，把这个节点从链表剔除，并放入末尾。
    - set(int key,int value)操作，哈希表中存在，则直接修改下value,不存在的话，需要判断当前是否达到最大容量，如果达到的话，把链表第一个节点剔除。然后把新节点放入链表尾部、以及哈希表中。
    
    代码实现如下:
    
    ```cpp
    #pragma once
    #include<list>
    #include<string>
    #include<memory>
    #include<unordered_map>
    using namespace std;
    class ListNode {
    public:
    	explicit ListNode(int _key, int _value) {
    		key = _key;
    		value = _value;
    		pre = nullptr;
    		nex = nullptr;
    	}
    	ListNode *pre,*nex;
    	int key, value;
    };
    class LRUcache {
    public:
    	explicit LRUcache(int _capacity):capacity(_capacity),Size(0){}
    	int get(int key) {
    		if (!hashmp.count(key))
    			return -1;
    		
    		ListNode* now = hashmp[key];
    		if (now == tail)
    			return now->value;
    		/*先把这个节点从链表中剔除*/
    		now->pre->nex = now->nex;
    		now->nex->pre = now->pre;
    		
    		/*把这个节点放入队尾*/
    		tail->nex = now;
    		now->pre = tail;
    		now->nex = nullptr;
    		tail = now;
    		return now->value;
    	}
    	void set(int key, int value) {
    		if (get(key) != -1) {
    			hashmp[key]->value = value;
    			return;
    		}
    		if (Size == capacity) {
    			ListNode* now = head->nex;
    			if (now == tail) {
    				now->pre->nex = nullptr;
    				tail = tail->pre;
    			}
    			else {
    				now->pre->nex = now->nex;
    				now->nex->pre = now->pre;
    			}
    			hashmp.erase(now->key);
    			Size--;
    			delete now;
    		}
    		ListNode* ins = new ListNode(key, value);
    		tail->nex = ins;
    		ins->pre = tail;
    		tail = ins;
    		hashmp.insert(make_pair(key, ins));
    		Size++;
    	}
    private:
    	ListNode* head = new ListNode(-1,-1);
    	ListNode* tail = head;
    	int capacity,Size;
    	unordered_map<int, ListNode*> hashmp;
    };
    ```
    
32.为什么STL模板库中把函数的实现都放入.h文件中?
    
    ​	因为STL中大多都是模板类，对于模板类，如果声明和实现分离的话，会在链接阶段报错。因为在编译.h的时候，编译器只看到声明，为看到定义，会把问题留给链接程序，同样编译.cpp时，它无法生成代码，因为它不知道具体要调用哪个类型。所以链接时会报出无定义成员的错误。
    
33.为什么`free(void *prt)`接口，没有块大小的参数，如何确定释放内存的大小？

因为分配内存块时，会在其头部保存一些额外的信息，记录内存块的大小和一个magic number用于检查数据完整性。
比如`ptr = malloc(20)` ptr指针前面就会记录这些额外的信息。

